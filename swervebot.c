#pragma config(Sensor, in1,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    centerLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in6,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, in8,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  leftTouch,      sensorTouch)
#pragma config(Sensor, dgtl7,  rightTouch,     sensorTouch)
#pragma config(Sensor, dgtl8,  sonarCM,        sensorSONAR_cm)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, driveRight, encoderPort, dgtl1)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop, reversed, driveLeft, encoderPort, dgtl3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int leftMotorTarget, rightMotorTarget;
int outputLeft, outputRight, sleepTime=300; //msec
float min=-127, max=127;
unsigned long prevTimeLeft=0, prevTimeRight=0;
float kp=3, ki=2, kd=6;
float errSumLeft=0, prevInputLeft=0;
float errSumRight=0, prevInputRight=0;
float errorLeft, errorRight;


task pid_left(){
  while(true){

    //calculate timeslice
    unsigned long now = nPgmTime;
    // float timeDiff = (float)(now-prevTimeLeft);

    //compute p i d terms
    float input = (SensorValue(-leftEncoder));
    errorLeft = leftMotorTarget - input;
    errSumLeft += (ki * errorLeft);
    float dInput = (input - prevInputLeft);

    outputLeft = kp * errorLeft + errSumLeft - kd * dInput;
    if(outputLeft > max){
      errSumLeft -= outputLeft - max;
      outputLeft = max;
    }
    else if(outputLeft < min){
      errSumLeft += min - outputLeft;
      outputLeft = min;
    }
    prevInputLeft = input;
    prevTimeLeft = now;
		SensorValue[leftEncoder]=0;
    wait1Msec(sleepTime);
  }
}

task pid_right(){
  while(true){

    //calculate timeslice
    unsigned long now = nPgmTime;
    // float timeDiff = (float)(now-prevTimeLeft);

    //compute p i d terms
    float input = (SensorValue(rightEncoder));
    errorRight = rightMotorTarget - input;
    errSumRight += (ki * errorRight);
    float dInput = (input - prevInputRight);

    outputRight = kp * errorRight + errSumRight - kd * dInput;
    if(outputRight > max){
      errSumRight -= outputRight - max;
      outputRight = max;
    }
    else if(outputRight < min){
      errSumRight += min - outputRight;
      outputRight = min;
    }
    prevInputRight = input;
    prevTimeRight = now;

		SensorValue[rightEncoder]=0;
    wait1Msec(sleepTime);
  }
}

task main()
{
leftMotorTarget = 70;
rightMotorTarget = 70;
startTask(pid_left,7);
startTask(pid_right,7);
	while(true){
		motor[leftMotor]=outputLeft;
		motor[rightMotor]=outputRight;
	}
}
